https://docs.google.com/spreadsheets/d/1CsMiR0DS5G7\_VZiukVZP6lyw5BlnX1GrERqoN9tqE6A/edit?usp=sharing

質問：このデータを使って、\*\*「7つのグループが36週間で一巡する、泊まり勤務ありの交代制シフト表」\*\*として活用したい  
例えば、  
Week 1 の「イ」の勤務（仕業番号215）は何日か、  
または、勤務（仕業番号10）を表示、  
Week 3 では一週間の予定表（仕業番号229）を表示、またはカレンダー表示するアプリ開発したい.

回答：素晴らしいアイデアですね！ご提示のCSVデータは、まさにそのようなアプリを開発するための宝の山です。

「7つのグループが36週間で一巡する交代制シフト表」をアプリとして活用するための開発の考え方と、具体的なステップを解説します。

\#\#\# アプリ開発の3つのステップ

アプリ開発を以下の3つのステップで進めていきましょう。

1\.  \*\*データの準備と読み込み\*\*: CSVファイルをプログラムで扱える形にする。  
2\.  \*\*基本機能の実装\*\*: 「特定の勤務を検索」「週の予定を表示」といった機能を作る。  
3\.  \*\*カレンダー機能の実装\*\*: 個人のシフトを月間カレンダーに表示する。

\---

\#\#\# ステップ1: データの準備と読み込み

まず、CSVデータをプログラムで簡単に扱えるようにします。ここでは、データ分析で広く使われるPython言語と\`pandas\`というライブラリを使う例をご紹介します。

\#\#\#\# 考え方  
1\.  CSVファイルを読み込みます。  
2\.  列に「週」「イ」「ロ」「ハ」「ニ」「ホ」「ヘ」「ト」という名前を付けます。  
3\.  「週」を基準にいつでもデータを引き出せるようにします。

\#\#\#\# Pythonコード例

\`\`\`python  
import pandas as pd  
import io

\# 提供されたCSVデータを文字列として読み込む (実際はファイルから読み込む)  
csv\_data \= """1,215,B 545/546(土休),160,泊172,明113,休,公  
19,B 533/534(土休),20,F-35,泊174,明117,休,公  
2,B 529/530(土休),10,F-24,★112,35(平休),129,公  
... (以下略) ...  
36,A 523/524(休),140,120(平休),219,F-2,7,公  
"""

\# CSVデータを読み込む  
\# 実際には pd.read\_csv('your\_file\_name.csv', ...) のようにファイル名を指定  
df \= pd.read\_csv(io.StringIO(csv\_data), header=None)

\# 列に名前を付ける  
df.columns \= \['週', 'イ', 'ロ', 'ハ', 'ニ', 'ホ', 'ヘ', 'ト'\]

\# 「週」の列をインデックス（索引）に設定して、データを引き出しやすくする  
df \= df.set\_index('週')

\# 週番号でソートして、1週目から順に並べる  
df \= df.sort\_index()

print("データ準備完了！")  
print(df.head()) \# 最初の5行を表示して確認  
\`\`\`  
これで、\`df\`という変数に、整理されたシフト表データが格納されました。

\---

\#\#\# ステップ2: 基本機能の実装

準備したデータを使って、ご要望の機能を一つずつ作っていきます。

\#\#\#\# 機能1: Week 1 の「イ」の勤務を表示

\`\`\`python  
\# 週番号とグループ名を指定して勤務内容を取得  
week\_num \= 1  
group\_name \= 'イ'

kinmu \= df.loc\[week\_num, group\_name\]  
print(f"Week {week\_num} の「{group\_name}」の勤務は: {kinmu}")  
\#=\> Week 1 の「イ」の勤務は: 215  
\`\`\`

\#\#\#\# 機能2: 勤務「10」がいつのシフトか検索

\`\`\`python  
\# 指定した勤務内容が含まれる場所を検索  
search\_kinmu \= '10'  
result \= \[\]  
for week, row in df.iterrows():  
    for group, value in row.items():  
        if str(value) \== search\_kinmu:  
            result.append({'週': week, 'グループ': group})

if result:  
    print(f"勤務「{search\_kinmu}」が見つかりました:")  
    for r in result:  
        print(f"  \- Week {r\['週'\]}, グループ {r\['グループ'\]}")  
else:  
    print(f"勤務「{search\_kinmu}」は見つかりませんでした。")  
\#=\> 勤務「10」が見つかりました:  
\#=\>   \- Week 2, グループ ロ  
\`\`\`

\#\#\#\# 機能3: Week 3 の一週間の予定表を表示

\`\`\`python  
\# 指定した週の予定を一覧で表示  
week\_num \= 3  
week\_schedule \= df.loc\[week\_num\]

print(f"--- Week {week\_num} の予定表 \---")  
for group, kinmu in week\_schedule.items():  
    print(f"{group}: {kinmu}")

\#=\> \--- Week 3 の予定表 \---  
\#=\> イ: 144  
\#=\> ロ: 104(平)  
\#=\> ハ: 229  
\#=\> ニ: F-5  
\#=\> ホ: 141/鷹B  
\#=\> ヘ: 休  
\#=\> ト: 公  
\`\`\`

\---

\#\#\# ステップ3: カレンダー機能の実装

これは少し高度になりますが、非常に便利な機能です。個人のシフトをカレンダーに表示するには、以下の情報が\*\*追加で必要\*\*になります。

\*   \*\*基準日\*\*: このシフト表の「Week 1」がいつから始まるか (例: \`2025-05-19\`)  
\*   \*\*自分の担当\*\*: 自分が「Week 1」の時にどのグループ (\`イ\`〜\`ト\`) を担当するか

\#\#\#\# 考え方  
1\.  ユーザーに「基準日」と「自分の担当グループ」を設定させます。  
2\.  表示したい月（例: 2025年6月）を指定します。  
3\.  その月の1日から末日まで、一日ずつ以下の計算を繰り返します。  
    a. その日が基準日から何週目にあたるかを計算する。  
    b. その週に自分の担当がどのグループに巡ってくるかを計算する (\`イ\`→\`ロ\`→\`ハ\`...のローテーション)。  
    c. シフト表データから、該当する週・グループの勤務内容を取得する。  
    d. カレンダーの日付の下に勤務内容を表示する。

\#\#\#\# Pythonコードのロジック（概念）  
※これは実際のコードではなく、処理の流れを示すものです。

\`\`\`python  
\# \--- ユーザー設定 \---  
基準日 \= "2025-05-19" \# Week 1 の月曜日  
自分の担当 \= "ハ"     \# 自分は Week 1 では「ハ」グループを担当  
表示月 \= "2025-06"

\# \--- 処理 \---  
グループリスト \= \['イ', 'ロ', 'ハ', 'ニ', 'ホ', 'ヘ', 'ト'\]  
自分の担当インデックス \= グループリスト.index(自分の担当) \# 「ハ」は2番目

カレンダーの全日付をループ:  
    日付 \= "2025-06-01"  
      
    \# 1\. 今が何週目か計算  
    経過日数 \= (日付 \- 基準日).days  
    今週の番号 \= (経過日数 // 7\) \+ 1 \# 1週目から始まるように調整  
      
    \# 2\. 今週の自分の担当グループを計算  
    \# (自分の担当インデックス \+ 週の経過数) % 7 でローテーションを計算  
    今週の自分の担当インデックス \= (自分の担当インデックス \+ (今週の番号 \- 1)) % 7  
    今週の自分のグループ \= グループリスト\[今週の自分の担当インデックス\]  
      
    \# 3\. シフト表から勤務内容を取得  
    \# 36週サイクルなので、(今週の番号 \- 1\) % 36 \+ 1 で実際の週番号を求める  
    シフト表の週番号 \= ((今週の番号 \- 1\) % 36\) \+ 1  
    今日の勤務 \= df.loc\[シフト表の週番号, 今週の自分のグループ\]  
      
    \# 4\. カレンダーに表示  
    print(f"{日付}: {今日の勤務}")  
\`\`\`

\#\#\# まとめと次のステップ

ここで示したコードのロジックを元に、本格的なアプリを開発できます。

\*   \*\*UI（ユーザーインターフェース）の構築\*\*:  
    \*   \*\*Webアプリ\*\*: \`Streamlit\`や\`Flask\`といったフレームワークを使うと、ブラウザで動く対話的なアプリを簡単に作れます。  
    \*   \*\*デスクトップアプリ\*\*: \`Tkinter\`や\`PyQt\`を使えば、PCで直接実行できるアプリが作れます。  
\*   \*\*データの永続化\*\*: ユーザー設定（基準日や担当グループ）をファイルに保存する機能を追加すると、毎回入力する手間が省けます。

まずはここで紹介したPythonコードを手元で動かしてみて、データが自由に扱える感覚を掴むところから始めるのがおすすめです。ご自身のアイデアを実現する素晴らしいアプリが完成することを楽しみにしています！

質問：ステップ1: データの準備と読み込み まず、CSVデータをプログラムで簡単に扱えるようにします。ここでは、データ分析で広く使われるPython言語とpandasというライブラリを使う例をご紹介します。 考え方 CSVファイルを読み込みます。 列に「週」「イ」「ロ」「ハ」「ニ」「ホ」「ヘ」「ト」という名前を付けます。 「週」を基準にいつでもデータを引き出せるようにします。との手順では、CSVファイルの読み込みでは週入りデータ、週なしデータ、週とイロハがはいったデータのどれ  
をつかうべきですか   
回答：素晴らしいご質問です。どのCSVファイルを選ぶかは、プログラムをどれだけシンプルで確実なものにできるかを左右する、非常に重要なポイントです。

結論から言うと、**『週入りデータのみ.csv』を使うのが最も適しています。**

---

### **各ファイルがなぜ適しているか・適していないかの理由**

それぞれのファイルを評価してみましょう。

#### **1\. 週入りデータのみ.csv（最適）**

1,215,B 545/546(土休),160,...

* **なぜ最適か？**  
  * **全ての情報を含んでいる**: 各行が「どの週」のデータなのかという最も重要な情報（週番号）が含まれています。  
  * **データが自己完結している**: ファイルの行の順番がシャッフルされても、週番号と勤務内容の関係は壊れません。これは非常に堅牢（ロバスト）なデータ形式です。  
  * **プログラムで扱いやすい**: 列名（イ, ロ, ハ...）はプログラム側で一度定義すれば済むため、データ自体に無くても全く問題ありません。  
* 

**プログラムの対応**  
ご提示したPythonコードは、まさに**このファイルを読み込むことを前提として書かれています。**  
Generated python  
      \# 1\. ヘッダーがないので header=None で読み込む  
df \= pd.read\_csv('週入りデータのみ.csv', header=None)

\# 2\. プログラムで列名（ヘッダー）を定義する  
df.columns \= \['週', 'イ', 'ロ', 'ハ', 'ニ', 'ホ', 'ヘ', 'ト'\]

\# 3\. '週'列を基準にソートしたり、データを引き出したりする  
df \= df.set\_index('週')  
df \= df.sort\_index()

*    

---

#### **2\. データのみ.csv（不適切）**

215,B 545/546(土休),160,泊172,...

* **なぜ不適切か？**  
  * **情報が欠落している**: 各行が何週目なのかという情報が完全に失われています。  
  * **順番に依存してしまう**: 1行目が1週目、2行目が19週目、3行目が2週目...という「見た目の順番」に依存してしまいます。もしプログラムでこの順番をハードコーディング（直接書き込むこと）すると、元の表のレイアウトが少しでも変わった場合にプログラムが破綻してしまいます。これは非常に危険で、避けるべきです。  
* 

---

#### **3\. 週とイロハが入ったデータ.csv（理想的だが、必須ではない）**

もし、CSVファイルの1行目に列名が書かれているファイルがあれば、それも非常に良い選択です。

週,イ,ロ,ハ,ニ,ホ,ヘ,ト  
1,215,B 545/546(土休),160,...

* **なぜ理想的か？**  
  * ファイル単体で全ての情報（データと列名）が完結しています。  
* 

**プログラムの対応**  
この場合、プログラムが少しだけシンプルになります。  
Generated python  
      \# header=None と df.columns=... の行が不要になる  
df \= pd.read\_csv('週とイロハが入ったデータ.csv') \# ← 読み込むだけでOK

df \= df.set\_index('週')  
df \= df.sort\_index()

*      
   IGNORE\_WHEN\_COPYING\_START  
   content\_copy download  
   Use code [with caution](https://support.google.com/legal/answer/13505487). Python  
  IGNORE\_WHEN\_COPYING\_END  
  ただし、「週入りデータのみ.csv」と比べて劇的に楽になるわけではありません。

### **まとめ**

| CSVファイルの種類 | 評価 | 理由 |
| :---- | :---- | :---- |
| **週入りデータのみ.csv** | **最適** | **プログラムで扱うために必要な情報（週番号）が全て含まれており、最も確実。** |
| データのみ.csv | 不適切 | 週番号の情報が欠落しており、プログラムが不安定になる原因となる。 |
| 週とイロハが入ったデータ.csv | 理想的 | 扱いやすいが、必須ではない。「週入りデータのみ」で十分対応可能。 |

したがって、ご提示いただいたコードは\*\*『週入りデータのみ.csv』を読み込むことを前提としており、これが最も確実で間違いのない方法です。\*\*安心してこのファイルを使って開発を進めてください。

質問：ステップ3: カレンダー機能の実装  
これは少し高度になりますが、非常に便利な機能です。個人のシフトをカレンダーに表示するには、以下の情報が追加で必要になります。

* 基準日: このシフト表の「Week 1」がいつから始まるか (例: 2025-05-19)  
* 自分の担当: 自分が「Week 1」の時にどのグループ (イ〜ト) を担当するか

#### 考え方

1. ユーザーに「基準日」と「自分の担当グループ」を設定させます。  
2. 表示したい月（例: 2025年6月）を指定します。  
3. その月の1日から末日まで、一日ずつ以下の計算を繰り返します。  
   a. その日が基準日から何週目にあたるかを計算する。  
   b. その週に自分の担当がどのグループに巡ってくるかを計算する (イ→ロ→ハ...のローテーション)。  
   c. シフト表データから、該当する週・グループの勤務内容を取得する。  
   d. カレンダーの日付の下に勤務内容を表示する。

#### Pythonコードのロジック（概念）

※これは実際のコードではなく、処理の流れを示すものです。  
Generated python  
\# \--- ユーザー設定 \---  
基準日 \= "2025-05-19" \# Week 1 の月曜日  
自分の担当 \= "ハ"     \# 自分は Week 1 では「ハ」グループを担当  
表示月 \= "2025-06"

\# \--- 処理 \---  
グループリスト \= \['イ', 'ロ', 'ハ', 'ニ', 'ホ', 'ヘ', 'ト'\]  
自分の担当インデックス \= グループリスト.index(自分の担当) \# 「ハ」は2番目

カレンダーの全日付をループ:  
    日付 \= "2025-06-01"  
      
    \# 1\. 今が何週目か計算  
    経過日数 \= (日付 \- 基準日).days  
    今週の番号 \= (経過日数 // 7\) \+ 1 \# 1週目から始まるように調整  
      
    \# 2\. 今週の自分の担当グループを計算  
    \# (自分の担当インデックス \+ 週の経過数) % 7 でローテーションを計算  
    今週の自分の担当インデックス \= (自分の担当インデックス \+ (今週の番号 \- 1)) % 7  
    今週の自分のグループ \= グループリスト\[今週の自分の担当インデックス\]  
      
    \# 3\. シフト表から勤務内容を取得  
    \# 36週サイクルなので、(今週の番号 \- 1\) % 36 \+ 1 で実際の週番号を求める  
    シフト表の週番号 \= ((今週の番号 \- 1\) % 36\) \+ 1  
    今日の勤務 \= df.loc\[シフト表の週番号, 今週の自分のグループ\]  
      
    \# 4\. カレンダーに表示  
    print(f"{日付}: {今日の勤務}")  
Use code [with caution](https://support.google.com/legal/answer/13505487).Python

### まとめと次のステップ

ここで示したコードのロジックを元に、本格的なアプリを開発できます。

* UI（ユーザーインターフェース）の構築:  
  * Webアプリ: StreamlitやFlaskといったフレームワークを使うと、ブラウザで動く対話的なアプリを簡単に作れます。  
  * デスクトップアプリ: TkinterやPyQtを使えば、PCで直接実行できるアプリが作れます。  
*   
* データの永続化: ユーザー設定（基準日や担当グループ）をファイルに保存する機能を追加すると、毎回入力する手間が省けます。

以上のカレンダー機能の実装を実現するためのステップを考えてください

回答：承知いたしました。カレンダー機能の実装を、具体的なプログラムコードを交えながら、ステップ・バイ・ステップで解説します。

誰でもコピー＆ペーストしてすぐに試せるように、**一つの完成したPythonスクリプト**として構成しました。

---

### **カレンダー機能実装の4ステップ**

1. **【準備】データの読み込みと整理**: まず、CSVデータをpandasで読み込み、プログラムで扱いやすい形に整えます。  
2. **【中核】勤務取得関数の作成**: 指定した日付の勤務を計算して返す、中心的な機能を持つ関数を作ります。  
3. **【表示】カレンダー生成関数の作成**: 1ヶ月分のカレンダーを生成し、各日付に勤務内容を埋め込んで表示する関数を作ります。  
4. **【実行】全てを統合して実行**: 上記の機能を組み合わせて、実際にカレンダーを表示します。

---

### **完成版Pythonスクリプト**

以下のコードをコピーして、shift\_calendar.pyのような名前で保存してください。  
（必要なライブラリはpandasだけです。インストールされていない場合は、ターミナルやコマンドプロンプトで pip install pandas を実行してください。）

Generated python  
     import pandas as pd  
import io  
from datetime import datetime, timedelta  
import calendar

\# \--- ステップ1: 【準備】データの読み込みと整理 \---  
def load\_and\_prepare\_data():  
    """CSVデータを読み込み、プログラムで扱えるDataFrameに変換する"""  
    csv\_data \= """  
    1,215,B 545/546(土休),160,泊172,明113,休,公  
    19,B 533/534(土休),20,F-35,泊174,明117,休,公  
    2,B 529/530(土休),10,F-24,★112,35(平休),129,公  
    20,157,A 513/514(休),27,F-20,163(休),119,公  
    3,144,104(平),229,F-5,141/鷹B,休,公  
    21,B 539/540(土休),138,156,泊34,明103,休,公  
    4,F-8,B 505/506,25,165(休)★,F-11,127,公  
    22,B 517/518(土休),136,124,F-19,209★,121,公  
    5,B 543/544(土休),126,26,泊178,明111,休,公  
    23,F-34,4,F-22,199★,11,123,公  
    6,146,102(平),227,193★,F-16,123,公  
    24,F-9,203,A 535/536(土),37(平),207,131,公  
    7,F-29,2,★114,41(平),鷹A,休,公  
    25,A 547/548(休),F-31,24,泊180,明109,休,公  
    8,169(休),B 503/504(土休),日勤予備,181(土休)★,23,147,公  
    26,B 511/512(土),134,F-26,231,167(休),145,公  
    9,F-15,B 509/510(土休),154,泊176,明107,休,公  
    27,12,130,F-25,213,A 549/D 予備,休,公  
    10,142,122,F-21,★110,F-12,9,公  
    28,A 541/542(休),223,F-17,187,177(休)★,143,公  
    11,A 537/538(休),33,F-10,155,153,休,公  
    29,16,148,F-33,泊170,明101,休,公  
    12,F-14,183,179★(土休),225,175(休),5,公  
    30,B 507/508(土),8,39(平),201,F-1,125,公  
    13,B 531/532,F-30,152,泊32,明1,休,公  
    31,F-7,191★,185,F-4,151,休,公  
    14,F-32,6,F-23,211★,29(土休),133,公  
    32,A 527/528(休),14,F-27,233,195,149,公  
    15,21(土休),A 521/522(土),31,F-3,本A予備,休,公  
    33,431/B予備/438,106(平),158,泊184,明105,休,公  
    16,F-6,A 501/502(休),205,189★,171(休),139,公  
    34,B 525/526(土),18,221,F-13,161,137,公  
    17,B 519/520(休),132,22,泊182,明115,休,公  
    35,F-18,197,150,宿泊予備,明け予備,休,公  
    18,F-28,108,B 515/516(ど),217,173(休),3,公  
    36,A 523/524(休),140,120(平休),219,F-2,7,公  
    """  
    df \= pd.read\_csv(io.StringIO(csv\_data.strip()), header=None)  
    df.columns \= \['週', 'イ', 'ロ', 'ハ', 'ニ', 'ホ', 'ヘ', 'ト'\]  
    df \= df.set\_index('週')  
    df \= df.sort\_index()  
    return df

\# \--- ステップ2: 【中核】勤務取得関数の作成 \---  
def get\_kinmu\_for\_date(target\_date, base\_date, base\_group, shift\_df):  
    """指定された日付の勤務内容を計算して返す"""  
    \# 1\. 基準日から何週目かを計算  
    elapsed\_days \= (target\_date \- base\_date).days  
    \# 週は月曜始まりと仮定。経過週数を計算 (0から始まる)  
    elapsed\_weeks \= elapsed\_days // 7  
      
    \# 2\. その週の自分の担当グループを計算 (イ→ロ→ハ...のローテーション)  
    group\_list \= shift\_df.columns.tolist() \# \['イ', 'ロ', ...\]  
    base\_group\_index \= group\_list.index(base\_group)  
    \# (基準のインデックス \+ 経過週数)をグループ数で割った余りで、今のグループが決まる  
    current\_group\_index \= (base\_group\_index \+ elapsed\_weeks) % len(group\_list)  
    current\_group \= group\_list\[current\_group\_index\]  
      
    \# 3\. シフト表の何週目に対応するかを計算 (36週サイクル)  
    \# (経過週数)を36で割った余りに1を足すと、1〜36のシフト表週番号になる  
    shift\_table\_week \= (elapsed\_weeks % 36\) \+ 1  
      
    \# 4\. シフト表から該当する勤務内容を取得  
    kinmu \= shift\_df.loc\[shift\_table\_week, current\_group\]  
    return kinmu

\# \--- ステップ3: 【表示】カレンダー生成関数の作成 \---  
def display\_monthly\_calendar(year, month, base\_date, base\_group, shift\_df):  
    """指定された月のカレンダーと勤務内容を表示する"""  
    print(f"--- {year}年 {month}月 のシフトカレンダー (担当: {base\_group}) \---")  
    print("  月      火      水      木      金      土      日")  
    print("-" \* 58\)

    cal \= calendar.Calendar(firstweekday=0) \# 月曜始まり  
      
    for week in cal.monthdatescalendar(year, month):  
        line \= ""  
        for day in week:  
            \# 表示月の日付でなければ空白にする  
            if day.month \!= month:  
                line \+= " " \* 8  
            else:  
                \# その日の勤務を取得  
                kinmu \= get\_kinmu\_for\_date(day, base\_date, base\_group, shift\_df)  
                \# 日付と勤務内容を整形して追加 (7文字に切り詰める)  
                cell\_text \= f"{day.day:2d} {kinmu\[:4\]}"  
                line \+= cell\_text.ljust(8) \# 8文字幅で左寄せ  
        print(line)  
    print("-" \* 58\)

\# \--- ステップ4: 【実行】全てを統合して実行 \---  
if \_\_name\_\_ \== "\_\_main\_\_":  
    \# \--- ユーザー設定 (ここを自分の情報に合わせて変更してください) \---  
      
    \# Week 1が始まる「月曜日」の日付  
    \# 元の表の「2025.5.16改正」から、その次の月曜日を想定  
    BASE\_DATE\_STR \= "2025-05-19"  
      
    \# Week 1の時の自分の担当グループ (イ, ロ, ハ, ニ, ホ, ヘ, ト のどれか)  
    MY\_BASE\_GROUP \= "ハ"  
      
    \# 表示したい年と月  
    TARGET\_YEAR \= 2025  
    TARGET\_MONTH \= 6  
    \# \----------------------------------------------------------------

    \# 文字列をdatetimeオブジェクトに変換  
    base\_date \= datetime.strptime(BASE\_DATE\_STR, "%Y-%m-%d")

    \# 1\. データを読み込む  
    shift\_data \= load\_and\_prepare\_data()

    \# 2\. カレンダーを表示する  
    display\_monthly\_calendar(TARGET\_YEAR, TARGET\_MONTH, base\_date, MY\_BASE\_GROUP, shift\_data)

    \# 翌月のカレンダーも表示してみる  
    display\_monthly\_calendar(TARGET\_YEAR, TARGET\_MONTH \+ 1, base\_date, MY\_BASE\_GROUP, shift\_data)  
   

### **使い方**

1. 上記のコードを shift\_calendar.py として保存します。  
2. 「**ユーザー設定**」の部分を自分の情報に合わせて書き換えます。  
   * BASE\_DATE\_STR: シフト表のWeek 1が始まる月曜日の日付を入力します。  
   * MY\_BASE\_GROUP: あなたがWeek 1の時に担当するグループ名（"イ"など）を入力します。  
   * TARGET\_YEAR, TARGET\_MONTH: 表示したいカレンダーの年と月を指定します。  
3. 

ターミナル（またはコマンドプロンプト）で、保存したファイルがあるディレクトリに移動し、以下のコマンドを実行します。  
Generated bash  
      python shift\_calendar.py

4.      
    IGNORE\_WHEN\_COPYING\_START  
    content\_copy download  
    Use code [with caution](https://support.google.com/legal/answer/13505487). Bash  
   IGNORE\_WHEN\_COPYING\_END

### **実行結果の例**

上記の設定のまま実行すると、以下のようなカレンダーが表示されます。

Generated code  
     \--- 2025年 6月 のシフトカレンダー (担当: ハ) \---  
  月      火      水      木      金      土      日  
\----------------------------------------------------------  
                                                 1  F-24  
 2  ★112    3  35(平   4  129     5  公      6  144     7  104(平  8  229  
 9  F-5     10 141/   11 休      12 公      13 F-8     14 B 505   15 25  
 16 165(休  17 F-11    18 127     19 公      20 B 543   21 126     22 26  
 23 泊178    24 明111    25 休      26 公      27 146     28 102(平  29 227  
 30 193★  
\----------------------------------------------------------  
\--- 2025年 7月 のシフトカレンダー (担当: ハ) \---  
  月      火      水      木      金      土      日  
\----------------------------------------------------------  
         1  F-16    2  123     3  公      4  F-29    5  2       6  ★114  
 7  41(平   8  鷹A     9  休      10 公      11 169(休  12 B 503   13 日勤予備  
 14 181(土  15 23      16 147     17 公      18 F-15    19 B 509   20 154  
 21 泊176    22 明107    23 休      24 公      25 142     26 122     27 F-21  
 28 ★110    29 F-12    30 9       31 公  
\----------------------------------------------------------  
     
IGNORE\_WHEN\_COPYING\_START  
content\_copy download  
Use code [with caution](https://support.google.com/legal/answer/13505487).  
IGNORE\_WHEN\_COPYING\_END

### **次のステップ**

この基本形を元に、さらにアプリを発展させることができます。

* **対話式の入力**: 実行するたびに年や月を input() 関数でユーザーに尋ねるようにする。  
* **GUI化**: Streamlit や Tkinter などのライブラリを使って、グラフィカルなカレンダーアプリにする。  
* **設定の保存**: ユーザー設定（基準日や担当グループ）をファイルに保存し、次回起動時に自動で読み込むようにする。

まずはこのスクリプトを動かして、自分のシフトが正しく表示されるか確認してみてください。

質問：次のステップ  
この基本形を元に、さらにアプリを発展させることができます。  
対話式の入力: 実行するたびに年や月を input() 関数でユーザーに尋ねるようにする。  
GUI化: Streamlit や Tkinter などのライブラリを使って、グラフィカルなカレンダーアプリにする。  
設定の保存: ユーザー設定（基準日や担当グループ）をファイルに保存し、次回起動時に自動で読み込むようにする。  
こちらの実現のためのステップを考えてください

回答：承知いたしました。基本形からアプリを発展させるための3つのステップ、「対話式の入力」「設定の保存」「GUI化」について、具体的な実装方法を交えながら解説します。

ステップは **①対話式入力 → ②設定の保存 → ③GUI化** の順で進めるのがおすすめです。機能を追加しながら、段階的にアプリをリッチにしていくことができます。

---

### **ステップ1: 対話式の入力機能の追加**

毎回コードを書き換えるのではなく、プログラム実行時にユーザーが情報を入力できるようにします。これにより、誰でも簡単に使えるツールになります。

#### **考え方**

* if \_\_name\_\_ \== "\_\_main\_\_" ブロック内の固定値を、input() 関数を使ってユーザーからの入力に置き換えます。  
* 入力された値が正しい形式かチェックする（バリデーション）処理を加えると、より親切なプログラムになります。

#### **実装コード例（shift\_calendar.py を修正）**

if \_\_name\_\_ \== "\_\_main\_\_" の部分を以下のように書き換えます。

Generated python  
     \# \--- ステップ4: 【実行】全てを統合して実行 \---  
if \_\_name\_\_ \== "\_\_main\_\_":  
    \# \--- ユーザー設定を対話式で取得 \---  
    print("--- シフトカレンダー 設定 \---")  
      
    \# BASE\_DATE\_STR \= "2025-05-19" \# ← この行を削除  
    BASE\_DATE\_STR \= input("Week 1が始まる月曜日の日付を入力してください (例: 2025-05-19): ")  
      
    \# MY\_BASE\_GROUP \= "ハ" \# ← この行を削除  
    MY\_BASE\_GROUP \= input("あなたがWeek 1で担当するグループ名を入力してください (イ〜ト): ")

    \# TARGET\_YEAR \= 2025 \# ← この行を削除  
    TARGET\_YEAR \= int(input("表示したいカレンダーの年を入力してください (例: 2025): "))

    \# TARGET\_MONTH \= 6 \# ← この行を削除  
    TARGET\_MONTH \= int(input("表示したいカレンダーの月を入力してください (例: 6): "))  
      
    \# \----------------------------------------------------------------

    \# 文字列をdatetimeオブジェクトに変換  
    try:  
        base\_date \= datetime.strptime(BASE\_DATE\_STR, "%Y-%m-%d")  
    except ValueError:  
        print("エラー: 日付の形式が正しくありません。'YYYY-MM-DD'形式で入力してください。")  
        exit() \# プログラムを終了

    \# 1\. データを読み込む  
    shift\_data \= load\_and\_prepare\_data()

    \# 入力されたグループ名が正しいかチェック  
    if MY\_BASE\_GROUP not in shift\_data.columns:  
        print(f"エラー: グループ名 '{MY\_BASE\_GROUP}' は存在しません。イ〜トのいずれかを入力してください。")  
        exit()

    \# 2\. カレンダーを表示する  
    display\_monthly\_calendar(TARGET\_YEAR, TARGET\_MONTH, base\_date, MY\_BASE\_GROUP, shift\_data)  
   

**この修正でどうなるか？**  
プログラムを実行すると、ターミナルに質問が表示され、ユーザーが日付やグループ名を入力すると、その内容に基づいたカレンダーが表示されるようになります。

---

### **ステップ2: 設定の保存・読み込み機能の追加**

毎回同じ情報を入力するのは面倒です。初回に入力した設定をファイルに保存し、次回以降は自動で読み込むようにします。

#### **考え方**

* 設定情報を config.json のような設定ファイルに保存します。（JSON形式はプログラムで扱いやすいです）  
* プログラム起動時にまず設定ファイルを読み込もうとします。  
* ファイルがあればその設定を使い、なければ（初回起動時など）ユーザーに入力を求めて、その内容を新しい設定ファイルとして保存します。  
* json ライブラリを使います。

#### **実装コード例**

if \_\_name\_\_ \== "\_\_main\_\_" の部分をさらに以下のように拡張します。

Generated python  
     import json \# ファイルの先頭にimportを追加

\# ... (他の関数はそのまま) ...

\# \--- ステップ4: 【実行】全てを統合して実行 \---  
if \_\_name\_\_ \== "\_\_main\_\_":  
    CONFIG\_FILE \= "shift\_config.json"  
    config \= {}

    \# \--- 設定ファイルの読み込み \---  
    try:  
        with open(CONFIG\_FILE, 'r', encoding='utf-8') as f:  
            config \= json.load(f)  
        print(f"設定ファイル '{CONFIG\_FILE}' を読み込みました。")  
    except FileNotFoundError:  
        print(f"設定ファイルが見つかりません。初回設定を行います。")

    \# \--- 設定値の取得 (ファイルにあればそれを使う、なければ尋ねる) \---  
    BASE\_DATE\_STR \= config.get("base\_date") or input("Week 1が始まる月曜日の日付を入力 (例: 2025-05-19): ")  
    MY\_BASE\_GROUP \= config.get("base\_group") or input("あなたがWeek 1で担当するグループ名を入力 (イ〜ト): ")  
      
    \# \--- 新しい設定を保存 \---  
    if not config: \# configが空の場合(初回設定時)  
        new\_config \= {"base\_date": BASE\_DATE\_STR, "base\_group": MY\_BASE\_GROUP}  
        with open(CONFIG\_FILE, 'w', encoding='utf-8') as f:  
            json.dump(new\_config, f, indent=4)  
        print(f"設定を '{CONFIG\_FILE}' に保存しました。次回から自動で読み込まれます。")

    \# \--- 表示する年月の入力 (これは毎回尋ねる) \---  
    TARGET\_YEAR \= int(input("表示したいカレンダーの年を入力 (例: 2025): "))  
    TARGET\_MONTH \= int(input("表示したいカレンダーの月を入力 (例: 6): "))

    \# ... (以降の処理はステップ1と同じ) ...  
    try:  
        base\_date \= datetime.strptime(BASE\_DATE\_STR, "%Y-%m-%d")  
    except ValueError:  
        \# ... (エラー処理)  
        exit()  
      
    shift\_data \= load\_and\_prepare\_data()  
      
    if MY\_BASE\_GROUP not in shift\_data.columns:  
        \# ... (エラー処理)  
        exit()

    display\_monthly\_calendar(TARGET\_YEAR, TARGET\_MONTH, base\_date, MY\_BASE\_GROUP, shift\_data)  
     
IGNORE\_WHEN\_COPYING\_START  
content\_copy download  
Use code [with caution](https://support.google.com/legal/answer/13505487). Python  
IGNORE\_WHEN\_COPYING\_END

**この修正でどうなるか？**

* 初回実行時：日付とグループ名を聞かれ、入力すると shift\_config.json というファイルが作成されます。  
* 2回目以降：日付とグループ名は自動で読み込まれ、表示したい年月だけを尋ねられます。

---

### **ステップ3: GUI化 (Streamlitを使ったWebアプリ)**

最後に、ターミナルの黒い画面（CUI）から、ブラウザで操作できるグラフィカルな画面（GUI）に進化させます。ここでは、データサイエンス分野で人気のStreamlitを使います。非常に簡単にWebアプリが作れます。

#### **準備**

streamlit をインストールします。

Generated bash  
     pip install streamlit  
     
IGNORE\_WHEN\_COPYING\_START  
content\_copy download  
Use code [with caution](https://support.google.com/legal/answer/13505487). Bash  
IGNORE\_WHEN\_COPYING\_END

#### **実装コード例**

shift\_calendar.py 全体を以下のように書き換えます。Streamlitは上から順に実行されるため、関数の定義と実行部分を少し整理します。

Generated python  
     import streamlit as st  
import pandas as pd  
import io  
from datetime import datetime  
import calendar  
import json

\# \--- これまでの関数定義はそのまま流用 \---  
\# ステップ1で作成した load\_and\_prepare\_data()  
\# ステップ2で作成した get\_kinmu\_for\_date()  
\# ... (ここに上記2つの関数をコピー＆ペースト)  
def load\_and\_prepare\_data():  
    \# ... (省略)  
def get\_kinmu\_for\_date(target\_date, base\_date, base\_group, shift\_df):  
    \# ... (省略)

\# \--- Streamlitアプリのメイン処理 \---  
st.set\_page\_config(page\_title="交代番シフトカレンダー", layout="wide")  
st.title("交代番シフトカレンダー")

\# \--- 1\. データと設定の準備 (サイドバーに配置) \---  
st.sidebar.header("個人設定")  
CONFIG\_FILE \= "shift\_config.json"  
config \= {}  
try:  
    with open(CONFIG\_FILE, 'r', encoding='utf-8') as f:  
        config \= json.load(f)  
except FileNotFoundError:  
    pass

\# 設定入力ウィジェット  
base\_date\_input \= st.sidebar.text\_input("① Week 1の開始日 (YYYY-MM-DD)", value=config.get("base\_date", "2025-05-19"))  
group\_list \= \['イ', 'ロ', 'ハ', 'ニ', 'ホ', 'ヘ', 'ト'\]  
\# 前回選択したグループをデフォルトにする  
try:  
    default\_index \= group\_list.index(config.get("base\_group", "イ"))  
except ValueError:  
    default\_index \= 0  
my\_base\_group \= st.sidebar.selectbox("② Week 1の担当グループ", group\_list, index=default\_index)

\# 設定保存ボタン  
if st.sidebar.button("この設定を保存"):  
    new\_config \= {"base\_date": base\_date\_input, "base\_group": my\_base\_group}  
    with open(CONFIG\_FILE, 'w', encoding='utf-8') as f:  
        json.dump(new\_config, f, indent=4)  
    st.sidebar.success("設定を保存しました！")

\# \--- 2\. 表示する年月を選択 \---  
st.header("カレンダー表示")  
current\_date \= datetime.now()  
target\_year \= st.number\_input("年", min\_value=2020, max\_value=2050, value=current\_date.year)  
target\_month \= st.number\_input("月", min\_value=1, max\_value=12, value=current\_date.month)

\# \--- 3\. カレンダーの生成と表示 \---  
try:  
    \# データを読み込み  
    shift\_df \= load\_and\_prepare\_data()  
    base\_date \= datetime.strptime(base\_date\_input, "%Y-%m-%d").date()

    \# カレンダーのHTMLを生成  
    cal \= calendar.HTMLCalendar(firstweekday=0)  
    \# CSSで見た目を少し整える  
    cal\_html \= cal.formatmonth(target\_year, target\_month)  
      
    \# 各日付に勤務を埋め込む  
    for day\_num in range(1, 32):  
        try:  
            target\_date \= datetime(target\_year, target\_month, day\_num).date()  
            kinmu \= get\_kinmu\_for\_date(target\_date, base\_date, my\_base\_group, shift\_df)  
              
            \# 勤務内容に応じて色を変える  
            color \= "gray"  
            if "泊" in kinmu: color \= "blue"  
            if "明" in kinmu: color \= "green"  
            if "休" in kinmu or "公" in kinmu: color \= "red"  
              
            \# HTMLを置換して勤務予定を挿入  
            kinmu\_html \= f'\<br\>\<span style="color:{color}; font-size: 0.8em; font-weight: bold;"\>{kinmu}\</span\>'  
            cal\_html \= cal\_html.replace(f"\>{day\_num}\</td\>", f"\>{day\_num}{kinmu\_html}\</td\>")  
        except ValueError:  
            \# 月の最終日を超えたらループを抜ける  
            break  
              
    \# StreamlitでHTMLを表示  
    st.markdown(cal\_html, unsafe\_allow\_html=True)

except Exception as e:  
    st.error(f"エラーが発生しました: {e}")  
     
IGNORE\_WHEN\_COPYING\_START  
content\_copy download  
Use code [with caution](https://support.google.com/legal/answer/13505487). Python  
IGNORE\_WHEN\_COPYING\_END

**この修正でどうなるか？**

1. このファイルを app.py などの名前で保存します。

ターミナルで以下のコマンドを実行します。  
Generated bash  
      streamlit run app.py

2.      
    IGNORE\_WHEN\_COPYING\_START  
    content\_copy download  
    Use code [with caution](https://support.google.com/legal/answer/13505487). Bash  
   IGNORE\_WHEN\_COPYING\_END  
3. 自動的にブラウザが立ち上がり、対話的なWebアプリが表示されます。  
   * 左側のサイドバーで日付やグループを設定し、「保存」ボタンを押せます。  
   * メイン画面で年と月を選ぶと、リアルタイムでカレンダーが更新されます。  
   * 勤務内容に応じて文字色が変わり、視覚的に分かりやすくなります。  
4. 

この3ステップで、最初のシンプルなスクリプトが、実用的で使いやすい本格的なアプリケーションに進化しました。まずはステップ1から順に試してみてください。

### プログラムで使用する名前: バージョン管理を意識した名前

将来的に複数のバージョンや改訂版を作ることを想定した、管理しやすい名前です。

| 項目 | 提案名 | 由来・ニュアンス |
| :---- | :---- | :---- |
| フォルダ名 | shift\_schedule\_v1 | 「シフトスケジュール バージョン1」。バージョン番号を明記。 |
| アプリ名 | Shift Schedule Viewer | 「シフトスケジュール閲覧ツール」。機能性を強調した名前。 |
| Pythonファイル名 | viewer.py | アプリ名に合わせて「閲覧」を意味する単語を選択。 |
| 設定ファイル名 | settings.json | config.json とほぼ同義。シンプルで分かりやすい。 |

このパターンの構成例:（案）  
Generated code  
shift\_schedule\_v1/  
├── viewer.py  
├── settings.json  
└── (CSVデータファイル)

\*\*「アプリの設計図」\*\*を固めるための、いくつかの重要な決定事項があります。これらを事前に決めておくことで、手戻りがなくスムーズに開発を進めることができます。  
以下に、決めるべきことをチェックリスト形式でまとめました。  
---

### プロジェクト開始前の決定事項チェックリスト

#### 1\. データの管理方針

アプリの心臓部であるCSVデータの扱い方を決めます。

* \[決定1\] CSVファイルの場所と名前:  
  * 場所: 作成するフォルダ shift\_schedule\_v1 の中に、Pythonファイルと一緒に入れますか？ (→ 推奨)  
  * 名前: 元のファイル名 隔日休 交代番 表... .csv は長すぎるため、プログラムで扱いやすい名前に変更します。  
    * 決定: shift\_data\_36w\_2025-05-16.csv にリネームする。  
  *   
*   
* \[決定2\] データ更新時のルール:  
  * 将来、シフト表が「第2版」に改訂された場合、どうしますか？  
    * 案A: 古い shift_data_36w_2025-05-16.csv を新しいもので上書きする。（シンプル）  
    * 案B: shift_data_36w_2025-05-16_v2.csv のように別名で保存し、プログラム側で読み込むファイルを選択できるようにする。（高度だが柔軟）  
  *   
  * まずは\*\*案B\*\*で進める。  
* 

#### 2\. 開発環境の準備

自分のPCで開発を始めるための準備です。

* \[決定3\] 仮想環境の利用:  
  * このプロジェクト専用の「仮想環境」を作成する (→ 強く推奨)  
  * 理由: PC本体のPython環境を汚さず、このアプリに必要なライブラリ（pandas, streamlit）だけをクリーンに管理できます。  
  * 手順: フォルダ内で以下のコマンドを実行するだけです。  
  * Generated bash

\# 1\. 仮想環境を作成 (venvという名前のフォルダができる)  
python \-m venv venv

\# 2\. 仮想環境を有効化 (Windows/Macでコマンドが少し違う)  
\# Windows (コマンドプロンプト):  
.\\venv\\Scripts\\activate  
\# Mac/Linux:  
source venv/bin/activate

\# 3\. 必要なライブラリをインストール

* pip install pandas streamlit  
  * Use code [with caution](https://support.google.com/legal/answer/13505487).Bash  
  *   
* 

#### 3\. アプリの具体的な仕様

ユーザーがどう操作し、何が見えるかを具体的にします。

* \[決定4\] 初期画面の表示:  
  * アプリを起動したとき、最初に何月のカレンダーを表示しますか？  
    * 案A: 現在の年月を自動で表示する。（便利）  
    * 案B: 常に固定の年月（例: 2025年6月）を表示する。（デバッグ向き）  
  *   
  * 案Aを採用。datetime.now() を使えば実現できます。  
*   
* \[決定5\] UI（見た目）のレイアウト:  
  * Streamlitのどの機能をどこに配置しますか？  
    * 提案:  
      * サイドバー (: 「個人設定（基準日、担当グループ）」と「設定保存ボタン」を配置する。  
      * メイン画面 (: 「アプリ名」、表示する「年・月」の選択欄、そして「カレンダー本体」を配置する。  
    *   
  *   
  * このレイアウトは、多くのWebアプリで採用されている直感的な構成です。  
*   
* \[決定6\] 表示する情報の詳細:  
  * カレンダーに表示する勤務内容を、どう表現しますか？  
    * 案A: 文字情報だけを表示する。（シンプル）  
    * 案B: 「泊」「休」「公」など特定の勤務に色やアイコンを付ける。（視覚的に分かりやすい）  
  *   
  * 決定：前回コードで実装した\*\*案B（色付け）\*\*は非常に効果的なので、この方針で進めるのが良いでしょう。  
    * 例: 泊→青、明→緑、休/公→赤、その他→黒  
  *   
* 

#### 4\. バージョン管理ツールの導入

\_v1というフォルダ名にしたことから、将来のバージョンアップを見据えていると思います。そのための準備です。

* \[決定7\] Gitの利用:  
  * ソースコードの変更履歴を管理するツール Git を使いますか？ (→ 推奨)  
  * メリット:  
    * 「昨日までは動いてたのに、どこを触ったら動かなくなったんだ？」という時に、簡単に元に戻せる。  
    * v1 から v2 へ機能を拡張する際に、安全に作業を進められる。  
  *   
  * 難しく考える必要はなく、最初のうちは「変更の記録を残すためのセーブポイント」として使うだけで十分です。  
* 

---

### まとめ

以上の決定事項を元に、プロジェクト shift\_schedule\_v1 は以下のような構成でスタートすることになります。  
Generated code  
shift\_schedule\_v1/  
├── venv/                 \# 仮想環境フォルダ (自動生成)  
├── viewer.py             \# アプリのメインコード  
├── settings.json         \# ユーザー設定ファイル  
└── sshift_data_36w_2025-05-16.csv        \# シフト表データ  
Use code [with caution](https://support.google.com/legal/answer/13505487).  
これらの点を最初に決めておけば、あとは一直線にコーディングに集中できます。  
